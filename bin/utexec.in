#! @PYTHON@
# -*- mode: python -*-
# 
# Script that collects, compiles, links and executes unit tests
import sys, getopt, os, glob, os.path

def Usage():
    print("""USAGE:
  utexec -h
  utexec [-t=NUMTASKS] [-s=SUBDIR] [-rnv] -C
  utexec [-t=NUMTASKS] [-s=SUBDIR] [-rnv] -1 UNITTEST [SUBTEST...]
  utexec [-t=NUMTASKS] [-s=SUBDIR] [-rnv] [-cpP] [UNITTEST...]

DESCRIPTION:
  utexec finds and executes C++, Python and parallel Python unittests
  for ESPResSo++. 

OPTIONS:
  -h  Output this help page.

  -C, --clean
      Clean up all files generated by compiling and linking the C++
      unittests.

  -1, --single-test
      Run the single test program UNITTEST. The list of SUBTESTs are
      passed as arguments to the test program.

  -p, -P and -c specify which type of unittests are to be run. If none
  of these options is specified, all unittests will be run.

  -p, --python
      Specify that the python unittests are to be run.

  -P, --parallel
      Specify that the parallel python unittests are to be run.

  -c, --cpp
      Specify that the C++ unittests are to be compiled, linked and
      run.

  -n, --dry-run
      Only print the commands that will be executed, don't actually
      run them.

  -v, --verbose
      Be more verbose.

  -s=SUBDIR|--subdir=SUBDIR
      Specify the subdirectory where the unittests reside, relative to
      the ESPResSo++ source directory 
        """ + top_srcdir + """

  -r, --recursive
      Recursively walk through all subdirectories to find unittests.

  -t=NUMTASKS|--num-tasks=NUMTASKS
      Specify how many tasks to use when parallel python unittests are
      run (defaults to 2). 
""")

def die(msg):
    print('ERROR: ' + msg)
    if savecwd: os.chdir(savecwd)
    sys.exit(1)

utdir = 'unittest'

##################################################
# CONSTANTS
top_srcdir="@abs_top_srcdir@"
top_srcdir = os.path.abspath(top_srcdir)
top_builddir="@abs_top_builddir@"
top_builddir = os.path.abspath(top_builddir)

PYRUN = "@PYTHON@"
ESPRESSO_MPIEXEC = "@ESPRESSO_MPIEXEC@"
HAVE_MPI = "@HAVE_MPI@"

# variables for C++ Unittest compilation
CPPFLAGS = os.getenv('CPPFLAGS', '@CPPFLAGS@')
LDFLAGS = os.getenv('LDFLAGS', '@LDFLAGS@')
CXX = os.getenv('CXX', '@CXX@')
CXXLD = os.getenv('CXXLD', CXX)
CXXFLAGS = os.getenv('CXXFLAGS', '@CXXFLAGS@')
RM = os.getenv('RM', '@RM@')
EXTERNAL_BOOST = ('@EXTERNAL_BOOST@' == 'yes')
BOOST_UNITTEST_LIBS = '@BOOST_UNITTEST_LIBS@'
LIBTOOL = os.getenv('LIBTOOL', os.path.join(top_builddir, 'libtool'))
LIBTOOLFLAGS = os.getenv('LIBTOOLFLAGS', '')
INCLUDES = os.getenv('INCLUDES', '')
CPPFLAGS += ' -I' + os.path.join(top_builddir, 'src')
CPPFLAGS += ' -I' + os.path.join(top_srcdir, 'src')
CPPFLAGS += ' -I' + os.path.join(top_srcdir, 'src' , 'include')
if not EXTERNAL_BOOST:
    CPPFLAGS += ' -I' + os.path.join(top_srcdir, 'contrib' , 'boost')
    LDFLAGS += ' -I' + os.path.join(top_builddir, 'contrib', 'boost')
LIBS = os.path.join(top_builddir, 'src' , 'libespresso_common.la') 
LIBS += ' ' + os.path.join(top_builddir, 'src' , 'libgenlogger.la') 
LIBS += ' ' + BOOST_UNITTEST_LIBS
LTCALL = LIBTOOL + ' --tag=CXX ' + LIBTOOLFLAGS

##################################################
# PARSE COMMAND LINE ARGS
try:
    optlist, tests = getopt.getopt(
        sys.argv[1:], 'nvhs:pcPt:C1r',
        ['dry-run', 'verbose', 'help', 'subdir=',
         'cpp', 'python', 'parallel', 
         'num-tasks=', 'clean', 'single-test', 'recursive'])
except getopt.GetoptError, e:
    print("Option error: " + str(e))
    Usage()
    sys.exit(1)

subdir = None
verbose = False
dryrun = False
clean = False
single_test = False
do_python = do_cpp = do_parallel = False
num_tasks = 2
recursive = False
for k, v in optlist:
    if k in ('-h', '--help'):
        Usage()
        sys.exit(0)
    elif k in ('-v', '--verbose'):
        verbose = True
    elif k in ('-s', '--subdir'):
        subdir = v
    elif k in ('-n', '--dry-run'):
        dryrun = True
    elif k in ('-p', '--python'):
        do_python = True
    elif k in ('-P', '--parallel'):
        do_parallel = True
    elif k in ('-c', '--cpp'):
        do_cpp = True
    elif k in ('-t', '--num-tasks'):
        num_tasks = int(v)
    elif k in ('-C', '--clean'):
        clean = True
    elif k in ('-1', '--single-test'):
        single_test = True
    elif k in ('-r', '--recursive'):
        recursive = True

if not clean and not do_python and not do_cpp and not do_parallel:
    do_python = do_cpp = do_parallel = True

##################################################
# DETERMINE BASEDIRS
savecwd = os.getcwd()

if subdir is not None:
    # subdir is specified
    if subdir.startswith('src'):
        basedir = os.path.join(top_srcdir, subdir)
    else:
        basedir = os.path.join(top_srcdir, 'src', subdir)
elif savecwd == top_builddir or savecwd == top_srcdir:
    basedir = os.path.join(top_srcdir, 'src')
elif savecwd.startswith(top_builddir):
    basedir = savecwd.replace(top_builddir, top_srcdir)
elif savecwd.startswith(top_srcdir):
    basedir = savecwd
else:
    die("""Cannot identify subdir, please change to a directory below the 
build directory
  """ + top_builddir + """
or the source directory 
  """ + top_srcdir)

# remove trailing slash if needs be
basedir = os.path.abspath(basedir)
# remove trailing utdir 
if basedir.endswith(utdir): basedir = basedir[:-len(utdir)]

if recursive:
    def pickutdirs(arg, dirname, fnames):
        # Remove utdir from the list
        # If it was not in there, this is not a dir that contains unittests
        try: fnames.remove(utdir)
        except ValueError: return
        dirs.append(dirname)
    dirs = []
    os.path.walk(basedir, pickutdirs, None)
else:
    dirs = [ basedir ]

if verbose: print("dirs=" + str(dirs))

success = []
error = []
compileerror = []
linkerror = []

for srcdir in dirs:
    ##################################################
    # DETERMINE SRCDIR
    # add trailing utdir to srcdir
    if not srcdir.endswith(utdir):  srcdir = os.path.join(srcdir, utdir)
    if verbose: print("SRCDIR=" + srcdir)

    # check whether srcdir is readable and executable
    if not os.access(srcdir, os.R_OK | os.X_OK):
        die("Cannot read and execute source dir \n  " + srcdir)

    subdir = srcdir[len(top_srcdir)+5:]
    builddir = srcdir.replace(top_srcdir, top_builddir)

    ##################################################
    # DETERMINE BUILDDIR
    # add trailing utdir to builddir
    if not builddir.endswith(utdir): builddir = os.path.join(builddir, utdir)
    if verbose: print("BUILDDIR=" + builddir)

    # check whether builddir is writeable, readable and executable
    if os.path.isdir(builddir):
        if not os.access(builddir, os.W_OK | os.X_OK | os.R_OK):
            die("Cannot read, write and execute build dir " + builddir)
        create_builddir = False
    else:
        create_builddir = True

    if recursive:
        print('**************************************************')
        print('**************************************************')
        print('** RUNNING TESTS IN SUBDIR ' + subdir)
        print('**************************************************')
        print('**************************************************')
    ##################################################
    # DETERMINE WHICH TESTS TO RUN
    os.chdir(srcdir)

    cpp_tests = []
    py_tests = []
    py_ptests = []

    def identify_test(test):
        # identify the different types of unittests
        global cpp_tests, py_tests, py_ptests
        if test.endswith('.py'):
            if test.startswith('test_'):
                py_tests.append(test)
                return
            elif test.startswith('ptest_'):
                py_ptests.append(test)
                return
            elif os.access('test_' + test, os.R_OK):
                py_tests.append('test_' + test)
                return
            elif os.access('ptest_' + test, os.R_OK):
                py_ptests.append('ptest_' + test)
                return
        elif test.endswith('.cpp'):
            if test.startswith('Test'):
                cpp_tests.append(test)
                return
            elif os.access('Test' + test, os.R_OK):
                cpp_tests.append('Test' + test)
                return
        elif test.startswith('Test') and os.access(test + '.cpp', os.R_OK):
            cpp_tests.append(test + '.cpp')
            return
        elif test.startswith('test_') and os.access(test + '.py', os.R_OK):
            py_tests.append(test + '.py')
            return
        elif test.startswith('ptest_') and os.access(test + '.py', os.R_OK):
            py_ptests.append(test + '.py')
            return
        else:
            found_one = False
            if os.access('Test' + test + '.cpp', os.R_OK):
                cpp_tests.append('Test' + test + '.cpp')
                found_one = True
            if os.access('test_' + test + '.py', os.R_OK):
                py_tests.append('test_' + test + '.py')
                found_one = True
            if os.access('ptest_' + test + '.py', os.R_OK):
                py_ptests.append('ptest_' + test + '.py')
                found_one = True
            if not found_one:
                die("Cannot identify test " + test)

    if single_test:
        if len(tests):
            identify_test(tests.pop(0))
            subtests = tests
        else:
            print("No unittest to handle.")
            sys.exit(2)
    elif len(tests):
        for test in tests:
            identify_test(test)
    else:
        # collect a list of unittests
        if clean or do_cpp:
            cpp_tests = glob.glob('Test*.cpp')
        if clean or do_python:
            py_tests = glob.glob('test_*.py')
        if clean or do_parallel:
            py_ptests = glob.glob('ptest_*.py')

    # Check whether any unittests are there to handle
    if not ((clean and (cpp_tests or py_tests or py_ptests)) or \
                (do_cpp and cpp_tests) or \
                (do_python and py_tests) or \
                (do_parallel and py_ptests)):
        print("No unittests to handle.")
        continue

    if not HAVE_MPI:
        py_tests.extend(py_ptests)

    if create_builddir:
        if verbose:
            print('Creating builddir.')
        # create builddir
        os.makedirs(builddir)

    os.chdir(builddir)

    if clean:
        print("Cleaning up.")
        if cpp_tests:
            LTCXXCLEAN = ''.join(
                [LTCALL, ' --mode=clean ', RM])
            if verbose:
                LTCXXCLEAN += ' -v'
            for test in cpp_tests:
                # strip ".cpp" from the end
                test = test[:-4]
                cmd = LTCXXCLEAN + ' ' + test + ' ' + test + '.lo'
                print(cmd)
                if not dryrun:
                    if os.system(cmd):
                        print('ERROR: Cleaning test %s failed.' % test)
                        sys.exit(1)
        if py_tests or py_ptests:
            for test in py_tests + py_ptests:
                # strip ".py" from the end
                test = test[:-3]
                cmd = RM + ' ' + test + '.pyc'
                print(cmd)
                if not dryrun:
                    if os.system(cmd):
                        print('ERROR: Cleaning test %s failed.' % test)
                        sys.exit(1)

    if do_cpp:
        print("Will do the following C++ unittests:")
        print(cpp_tests)
    if do_python:
        print("Will do the following Python unitests:")
        print(py_tests)
    if HAVE_MPI and do_parallel:
        print("Will do the following parallel Python tests:")
        print(py_ptests)
    if single_test:
        print("Will do these subtests:")
        print(subtests)

    if do_cpp and cpp_tests:
        print("\n**************************************************")
        print('**** COMPILING, LINKING AND RUNNING C++ UNITTESTS')
        ##################################################
        # COMBINE THE COMPILATION AND LINKER COMMANDS
        LTCXXCOMPILE = ''.join(
            [LTCALL,
             ' --mode=compile ', CXX,
             ' ', INCLUDES,
             ' ', CPPFLAGS,
             ' ', CXXFLAGS])
        LTCXXLINK = ''.join(
            [LTCALL,
             ' --mode=link ', CXXLD,
             ' ', CXXFLAGS,
             ' ', LDFLAGS,
             ' ', LIBS])
        LTRUN = LTCALL + ' --mode=execute'
        if verbose:
            LTRUN += ' -v'

            print("LTCXXCOMPILE = " + LTCXXCOMPILE)
            print("LTCXXLINK = " + LTCXXLINK)
            print("LTRUN = " + LTRUN)

        ##############################################
        # COMPILE, LINK AND RUN C++ UNITTESTS
        for test in cpp_tests:
            testname = os.path.join(subdir, test) 
            print("**************************************************")
            print("** " + testname)

            # strip ".cpp" from the end
            test = test[:-4]

            print('** COMPILING ' + testname)
            cmd = LTCXXCOMPILE + ' -c ' + os.path.join(srcdir, test + '.cpp')
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    print('ERROR: Compiling test %s failed.' % test)
                    compileerror.append(testname)
                    continue

            print('\n** LINKING ' + testname)
            cmd = LTCXXLINK + ' ' + test + '.lo -o ' + test
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    linkerror.append(testname)
                    continue

            print('\n** RUNNING ' + testname)
            cmd = LTRUN + ' ./' + test
            if verbose:
                cmd += ' --log_level=test_suite'
            if single_test and subtests:
                cmd += ' --run_test=' + ','.join(subtests)
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    error.append(testname)
                else:
                    success.append(testname)
                print('')

    ##############################################
    # EXECUTE PYTHON UNITTESTS
    if do_python and py_tests:
        print("\n**************************************************")
        print('**** RUNNING PYTHON UNITTESTS')
        for test in py_tests:
            testname = os.path.join(subdir, test) 
            print("**************************************************")
            print("** " + testname)
            cmd = PYRUN + ' ' + os.path.join(srcdir, test)
            if verbose: cmd += ' -v'
            if single_test:
                cmd += ' ' + ' '.join(subtests)
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    error.append(testname)
                else:
                    success.append(testname)
                print('')

    ##############################################
    # EXECUTE PARALLEL PYTHON UNITTESTS
    if HAVE_MPI and do_parallel and py_ptests:
        if verbose:
            print('Executing ptests using %s MPI tasks.' % num_tasks)
        print("\n**************************************************")
        print('**** RUNNING PARALLEL PYTHON UNITTESTS (%d CPUs)' % num_tasks)
        PARALLELPYTHON = ESPRESSO_MPIEXEC + ' -n ' + str(num_tasks) + ' ' + PYRUN
        for test in py_ptests:
            testname = os.path.join(subdir, test) 
            print("**************************************************")
            print("** " + testname)
            cmd = PARALLELPYTHON + ' ' + os.path.join(srcdir, test)
            if verbose: cmd += ' -v'
            if single_test:
                cmd += ' ' + ' '.join(subtests)
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    error.append(testname)
                else:
                    success.append(testname)
                print('')

print("**************************************************")
print("**************************************************")
print("****************** SUMMARY ***********************")
print("**************************************************")
print("**************************************************")

if verbose and success:
    print('The following tests were successfull:')
    print('  ' + '\n  '.join(success) + '\n')
if error:
    print('The following tests had errors:')
    print('  ' + '\n  '.join(error) + '\n')
if compileerror:
    print('The following tests had compilation errors:')
    print('  ' + '\n  '.join(compileerror) + '\n')
if linkerror:
    print('The following tests had linking errors:')
    print('  ' + '\n  '.join(linkerror) + '\n')

print(str(len(success)) + ' successful, ' 
      + str(len(error)) + ' errors, ' 
      + str(len(compileerror)) + ' compilation errors, ' 
      + str(len(linkerror)) + ' linking errors')
