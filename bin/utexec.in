#! @PYTHON@
# -*- mode: python -*-
# 
# Script that collects, compiles, links and executes unit tests
import sys, getopt, os, glob, os.path

def Usage():
    print("""USAGE:
  utexec -h
  utexec [-t=NUMTASKS] [-s=SUBDIR] [-nv] -C
  utexec [-t=NUMTASKS] [-s=SUBDIR] [-nv] -1 UNITTEST [SUBTEST...]
  utexec [-t=NUMTASKS] [-s=SUBDIR] [-nv] [-cpP] [UNITTEST...]

DESCRIPTION:
  utexec finds and executes C++, Python and parallel Python unittests
  for ESPResSo++. 

OPTIONS:
  -h  Output this help page.

  -C|--clean
      Clean up all files generated by compiling and linking the C++
      unittests.

  -1|--single-test
      Run the single test program UNITTEST. The list of SUBTESTs are
      passed as arguments to the test program.

  -p, -P and -c specify which type of unittests are to be run. If none
  of these options is specified, all unittests will be run.

  -p|--python
      Specify that the python unittests are to be run.

  -P|--parallel
      Specify that the parallel python unittests are to be run.

  -c|--cpp
      Specify that the C++ unittests are to be compiled, linked and
      run.

  -n|--dry-run
      Only print the commands that will be executed, don't actually
      run them.

  -v|--verbose
      Be more verbose.

  -s=SUBDIR|--subdir=SUBDIR
      Specify the subdirectory where the unittests reside, relative to
      the ESPResSo++ source directory 
        """ + top_srcdir + """

  -t=NUMTASKS|--num-tasks=NUMTASKS
      Specify how many tasks to use when parallel python unittests are
      run (defaults to 2). 
""")

def die(msg):
    print('ERROR: ' + msg)
    if savecwd: os.chdir(savecwd)
    sys.exit(1)

utdir = 'unittest'

##################################################
# CONSTANTS
top_srcdir="@abs_top_srcdir@"
top_builddir="@abs_top_builddir@"

PYRUN = "@PYTHON@"
ESPRESSO_MPIEXEC = "@ESPRESSO_MPIEXEC@"
HAVE_MPI = "@HAVE_MPI@"

# variables for C++ Unittest compilation
CPPFLAGS = os.getenv('CPPFLAGS', '@CPPFLAGS@')
LDFLAGS = os.getenv('LDFLAGS', '@LDFLAGS@')
CXX = os.getenv('CXX', '@CXX@')
CXXLD = os.getenv('CXXLD', CXX)
CXXFLAGS = os.getenv('CXXFLAGS', '@CXXFLAGS@')
RM = os.getenv('RM', '@RM@')
EXTERNAL_BOOST = ('@EXTERNAL_BOOST@' == 'yes')
BOOST_UNITTEST_LIBS = '@BOOST_UNITTEST_LIBS@'
LIBTOOL = os.getenv('LIBTOOL', os.path.join(top_builddir, 'libtool'))
LIBTOOLFLAGS = os.getenv('LIBTOOLFLAGS', '')
INCLUDES = os.getenv('INCLUDES', '')
CPPFLAGS += ' -I' + os.path.join(top_builddir, 'src')
CPPFLAGS += ' -I' + os.path.join(top_srcdir, 'src')
CPPFLAGS += ' -I' + os.path.join(top_srcdir, 'src' , 'include')
if not EXTERNAL_BOOST:
    CPPFLAGS += ' -I' + os.path.join(top_srcdir, 'contrib' , 'boost')
    LDFLAGS += ' -I' + os.path.join(top_builddir, 'contrib', 'boost')
LIBS = os.path.join(top_builddir, 'src' , 'libespresso_common.la') 
LIBS += ' ' + BOOST_UNITTEST_LIBS
LTCALL = LIBTOOL + ' --tag=CXX ' + LIBTOOLFLAGS

##################################################
# PARSE COMMAND LINE ARGS
try:
    optlist, tests = getopt.getopt(
        sys.argv[1:], 'nvhs:pcPt:C1',
        ['dry-run', 'verbose', 'help', 'subdir=',
         'cpp', 'python', 'parallel', 
         'num-tasks=', 'clean', 'single-test'])
except getopt.GetoptError, e:
    print("Option error: " + str(e))
    Usage()
    sys.exit(1)

subdir = None
verbose = False
dryrun = False
clean = False
single_test = False
do_python = do_cpp = do_parallel = False
num_tasks = 2
for k, v in optlist:
    if k == '-h' or k == '--help':
        Usage()
        sys.exit(0)
    elif k == '-v' or k == '--verbose':
        verbose = True
    elif k == '-s' or k == '--subdir':
        subdir = v
    elif k == '-n' or k == '--dry-run':
        dryrun = True
    elif k == '-p' or k == '--python':
        do_python = True
    elif k == '-P' or k == '--parallel':
        do_parallel = True
    elif k == '-c' or k == '--cpp':
        do_cpp = True
    elif k == '-t' or k == '--num-tasks':
        num_tasks = int(v)
    elif k == '-C' or k == '--clean':
        clean = True
    elif k == '-1' or k == '--single-test':
        single_test = True

if not clean and not do_python and not do_cpp and not do_parallel:
    do_python = do_cpp = do_parallel = True

##################################################
# DETERMINE DIRS
savecwd = os.getcwd()

if subdir is not None:
    # subdir is specified
    if subdir.startswith('src'):
        srcdir = os.path.join(top_srcdir, subdir)
        builddir = os.path.join(top_builddir, subdir)
    else:
        srcdir = os.path.join(top_srcdir, 'src', subdir)
        builddir = os.path.join(top_builddir, 'src', subdir)
elif savecwd == top_builddir or savecwd == top_srcdir:
    builddir = os.path.join(top_builddir, 'src')
    srcdir = os.path.join(top_srcdir, 'src')
elif savecwd.startswith(top_builddir):
    builddir = savecwd
    srcdir = builddir.replace(top_builddir, top_srcdir)
elif savecwd.startswith(top_srcdir):
    srcdir = savecwd
    builddir = srcdir.replace(top_srcdir, top_builddir)
else:
    die("""Cannot identify subdir, please change to a directory below the 
build directory
  """ + top_builddir + """
or the source directory 
  """ + top_srcdir)
    
##################################################
# DETERMINE SRCDIR
# add trailing utdir to srcdir
if not srcdir.endswith(utdir):  srcdir = os.path.join(srcdir, utdir)
if verbose: print("SRCDIR=" + srcdir)

# check whether srcdir is readable and executable
if not os.access(srcdir, os.R_OK | os.X_OK):
    die("Cannot read and execute source dir \n  " + srcdir)

##################################################
# DETERMINE BUILDDIR
# add trailing utdir to builddir
if not builddir.endswith(utdir): builddir = os.path.join(builddir, utdir)
if verbose: print("BUILDDIR=" + builddir)

# check whether builddir is writeable, readable and executable
if os.path.isdir(builddir):
    if not os.access(builddir, os.W_OK | os.X_OK | os.R_OK):
        die("Cannot read, write and execute build dir " + builddir)
    create_builddir = False
else:
    create_builddir = True


##################################################
# DETERMINE WHICH TESTS TO RUN
os.chdir(srcdir)

cpp_tests = []
py_tests = []
py_ptests = []

def identify_test(test):
    # identify the different types of unittests
    global cpp_tests, py_tests, py_ptests
    if test.endswith('.py'):
        if test.startswith('test_'):
            py_tests.append(test)
            return
        elif test.startswith('ptest_'):
            py_ptests.append(test)
            return
        elif os.access('test_' + test, os.R_OK):
            py_tests.append('test_' + test)
            return
        elif os.access('ptest_' + test, os.R_OK):
            py_ptests.append('ptest_' + test)
            return
    elif test.endswith('.cpp'):
        if test.startswith('Test'):
            cpp_tests.append(test)
            return
        elif os.access('Test' + test, os.R_OK):
            cpp_tests.append('Test' + test)
            return
    elif test.startswith('Test') and os.access(test + '.cpp', os.R_OK):
        cpp_tests.append(test + '.cpp')
        return
    elif test.startswith('test_') and os.access(test + '.py', os.R_OK):
        py_tests.append(test + '.py')
        return
    elif test.startswith('ptest_') and os.access(test + '.py', os.R_OK):
        py_ptests.append(test + '.py')
        return
    elif os.access('Test' + test + '.cpp', os.R_OK):
        cpp_tests.append('Test' + test + '.cpp')
        return
    elif os.access('test_' + test + '.py', os.R_OK):
        py_tests.append('test_' + test + '.py')
        return
    elif os.access('ptest_' + test + '.py', os.R_OK):
        py_ptests.append('ptest_' + test + '.py')
        return
    die("Cannot identify test " + test)

if single_test:
    if len(tests):
        identify_test(tests.pop(0))
        subtests = tests
    else:
        print("No unittest to handle.")
        sys.exit(2)
elif len(tests):
    for test in tests:
        identify_test(test)
else:
    # collect a list of unittests
    if clean or do_cpp:
        cpp_tests = glob.glob('Test*.cpp')
    if clean or do_python:
        py_tests = glob.glob('test_*.py')
    if clean or do_parallel:
        py_ptests = glob.glob('ptest_*.py')

# Check whether any unittests are there to handle
if not ((clean and (cpp_tests or py_tests or py_ptests)) or \
            (do_cpp and cpp_tests) or \
            (do_python and py_tests) or \
            (do_parallel and py_ptests)):
    print("No unittests to handle.")
    sys.exit(0)

if not HAVE_MPI:
    py_tests.extend(py_ptests)

if create_builddir:
    if verbose:
        print('Creating builddir.')
    # create builddir
    os.makedirs(builddir)

os.chdir(builddir)

if clean:
    print("Cleaning up.")
    if cpp_tests:
        LTCXXCLEAN = ''.join(
            [LTCALL, ' --mode=clean ', RM])
        if verbose:
            LTCXXCLEAN += ' -v'
        for test in cpp_tests:
            # strip ".cpp" from the end
            test = test[:-4]
            cmd = LTCXXCLEAN + ' ' + test + ' ' + test + '.lo'
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    print('ERROR: Cleaning test %s failed.' % test)
                    sys.exit(1)
    if py_tests or py_ptests:
        for test in py_tests + py_ptests:
            # strip ".py" from the end
            test = test[:-3]
            cmd = RM + ' ' + test + '.pyc'
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    print('ERROR: Cleaning test %s failed.' % test)
                    sys.exit(1)

if do_cpp:
    print("Will do the following C++ unittests:")
    print(cpp_tests)
if do_python:
    print("Will do the following Python unitests:")
    print(py_tests)
if HAVE_MPI and do_parallel:
    print("Will do the following parallel Python tests:")
    print(py_ptests)
if single_test:
    print("Will do these subtests:")
    print(subtests)

if do_cpp and cpp_tests:
    print("\n**************************************************")
    print('**** COMPILING AND LINKING C++ UNITTESTS')
    ##################################################
    # COMBINE THE COMPILATION AND LINKER COMMANDS
    LTCXXCOMPILE = ''.join(
        [LTCALL,
         ' --mode=compile ', CXX,
         ' ', INCLUDES,
         ' ', CPPFLAGS,
         ' ', CXXFLAGS])
    LTCXXLINK = ''.join(
        [LTCALL,
         ' --mode=link ', CXXLD,
         ' ', CXXFLAGS,
         ' ', LDFLAGS,
         ' ', LIBS])
    LTRUN = LTCALL + ' --mode=execute'
    if verbose:
        LTRUN += ' -v'
        
        print("LTCXXCOMPILE = " + LTCXXCOMPILE)
        print("LTCXXLINK = " + LTCXXLINK)
        print("LTRUN = " + LTRUN)
        
    ##############################################
    # COMPILE AND LINK C++ UNITTESTS
    for test in cpp_tests:
        print("**************************************************")
        print("** " + test)

        # strip ".cpp" from the end
        test = test[:-4]

        print('** COMPILING ' + test)
        cmd = LTCXXCOMPILE + ' -c ' + os.path.join(srcdir, test + '.cpp')
        print(cmd)
        if not dryrun:
            if os.system(cmd):
                print('ERROR: Compiling test %s failed.' % test)
                sys.exit(1)
                
        print('\n** LINKING ' + test)
        cmd = LTCXXLINK + ' ' + test + '.lo -o ' + test
        print(cmd)
        if not dryrun:
            if os.system(cmd):
                print('ERROR: Linking test %s failed.' % test)
                sys.exit(1)
                
    ##############################################
    # EXECUTE C++ UNITTESTS
    print("\n**************************************************")
    print('**** RUNNING C++ UNITTESTS')
    for test in cpp_tests:
        print("**************************************************")
        print("** " + test)
        # strip ".cpp" from the end
        cmd = LTRUN + ' ' + test[:-4]
        if verbose:
            cmd += ' --log_level=test_suite'
        if single_test and subtests:
            cmd += ' --run_test=' + ','.join(subtests)
        print(cmd)
        if not dryrun:
            os.system(cmd)
            print('')

##############################################
# EXECUTE PYTHON UNITTESTS
if do_python and py_tests:
    print("\n**************************************************")
    print('**** RUNNING PYTHON UNITTESTS')
    for test in py_tests:
        print("**************************************************")
        print("** " + test)
        cmd = PYRUN + ' ' + os.path.join(srcdir, test)
        if verbose: cmd += ' -v'
        if single_test:
            cmd += ' ' + ' '.join(subtests)
        print(cmd)
        if not dryrun:
            os.system(cmd)
            print('')

##############################################
# EXECUTE PARALLEL PYTHON UNITTESTS
if HAVE_MPI and do_parallel and py_ptests:
    if verbose:
        print('Executing ptests using %s MPI tasks' % num_tasks)
    print("\n**************************************************")
    print('**** RUNNING PARALLEL PYTHON UNITTESTS (%d CPUs)' % num_tasks)
    PARALLELPYTHON = ESPRESSO_MPIEXEC + ' -n ' + str(num_tasks) + ' ' + PYRUN
    for test in py_ptests:
        print("**************************************************")
        print("** " + test)
        cmd = PARALLELPYTHON + ' ' + os.path.join(srcdir, test)
        if verbose: cmd += ' -v'
        if single_test:
            cmd += ' ' + ' '.join(subtests)
        print(cmd)
        if not dryrun:
            os.system(cmd)
            print('')

