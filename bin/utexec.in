#! @PYTHON@
# -*- mode: python -*-
# 
# Script that collects, compiles, links and executes unit tests
import sys, getopt, os, glob, os.path

def Usage():
    print("""USAGE:
  utexec -h
  utexec -C
  utexec [-nvpP] [-t=NUMTASKS] [-s=SRCDIR] [-b=BUILDDIR] [UNITTESTS...]

DESCRIPTION:
  utexec finds and executes C++, Python and parallel Python unittests
  for ESPResSo++. 

OPTIONS:
  -p, -P and -c specify which type of unittests are to be run. If none
  of these options is specified, all unittests will be run.

  -h  Output this help page.

  -C|--clean
      Clean up all files generated by compiling and linking the C++
      unittests.

  -p|--python
      Specify that the python unittests are to be run.

  -P|--parallel
      Specify that the parallel python unittests are to be run.

  -c|--cpp
      Specify that the C++ unittests are to be compiled, linked and
      run.

  -n|--dry-run
      Only print the commands that will be executed, don't actually
      run them.

  -v|--verbose
      Be more verbose.

  -s=SRCDIR|--srcdir=SRCDIR
      Specify the source dir where the unittest are to be found.

  -b=BUILDDIR|--buildir=BUILDDIR
      Specify the build dir where the unittest are to be built and
      executed.

  -t=NUMTASKS|--num-tasks=NUMTASKS
      Specify how many tasks to use when parallel python unittests are
      run (defaults to 2). 
""")

def die(msg):
    print('ERROR: ' + msg)
    if savecwd: os.chdir(savecwd)
    sys.exit(1)

utdir = 'unittest/'

##################################################
# CONSTANTS
top_srcdir="@abs_top_srcdir@"
if not top_srcdir.endswith('/'): top_srcdir += '/'
top_builddir="@abs_top_builddir@"
if not top_builddir.endswith('/'): top_builddir += '/'

PYRUN = "@PYTHON@"
ESPRESSO_MPIEXEC = "@ESPRESSO_MPIEXEC@"
HAVE_MPI = "@HAVE_MPI@"

# variables for C++ Unittest compilation
CPPFLAGS = os.getenv('CPPFLAGS', '@CPPFLAGS@')
LDFLAGS = os.getenv('LDFLAGS', '@LDFLAGS@')
CXX = os.getenv('CXX', '@CXX@')
CXXLD = os.getenv('CXXLD', CXX)
CXXFLAGS = os.getenv('CXXFLAGS', '@CXXFLAGS@')
RM = os.getenv('RM', '@RM@')
UTEXEC_CPPFLAGS = '@UTEXEC_CPPFLAGS@'
UTEXEC_LDFLAGS = '@UTEXEC_LDFLAGS@'
BOOST_UNITTEST_LIBS = '@BOOST_UNITTEST_LIBS@'
LIBTOOL = os.getenv('LIBTOOL', top_builddir + 'libtool')
LIBTOOLFLAGS = os.getenv('LIBTOOLFLAGS', '')
INCLUDES = os.getenv('INCLUDES', '')
CPPFLAGS = ''.join(
    [CPPFLAGS,
     ' -I', top_builddir, 'src',
     ' -I', top_srcdir, 'src',
     ' -I', top_srcdir, 'src/include',
     ' ', UTEXEC_CPPFLAGS])
LDFLAGS += ' ' + UTEXEC_LDFLAGS
LIBS = top_builddir + 'src/libespresso_common.la ' + BOOST_UNITTEST_LIBS
LTCALL = LIBTOOL + ' --tag=CXX ' + LIBTOOLFLAGS

##################################################
# PARSE COMMAND LINE ARGS
try:
    optlist, tests = getopt.getopt(
        sys.argv[1:], 'nvhs:b:pcPt:C',
        ['dry-run', 'verbose', 'help', 'srcdir=', 'builddir=',
         'cpp', 'python', 'parallel', 'num-tasks=', 'clean'])
except getopt.GetoptError, e:
    print("Option error: " + str(e))
    Usage()
    sys.exit(1)

builddir = None
srcdir = None
verbose = False
dryrun = False
clean = False
do_python = do_cpp = do_parallel = False
num_tasks = 2
for k, v in optlist:
    if k == '-h' or k == '--help':
        Usage()
        sys.exit(0)
    elif k == '-v' or k == '--verbose':
        verbose = True
    elif k == '-s' or k == '--srcdir':
        srcdir = v
    elif k == '-b' or k == '--builddir':
        builddir = v
    elif k == '-n' or k == '--dry-run':
        dryrun = True
    elif k == '-p' or k == '--python':
        do_python = True
    elif k == '-P' or k == '--parallel':
        do_parallel = True
    elif k == '-c' or k == '--cpp':
        do_cpp = True
    elif k == '-t' or k == '--num-tasks':
        num_tasks = int(v)
    elif k == '-C' or k == '--clean':
        clean = True

if not clean and not do_python and not do_cpp and not do_parallel:
    do_python = do_cpp = do_parallel = True

##################################################
# DETERMINE DIRS
savecwd = os.getcwd()

# normalize dirs given in options
if srcdir is not None:
    srcdir = os.path.abspath(srcdir)
if builddir is not None:    
    builddir = os.path.abspath(builddir)

# determine the dirs not given in options
if srcdir is not None and builddir is None:
    builddir = srcdir.replace(top_srcdir, top_builddir)
elif builddir is not None and srcdir is None:
    srcdir = builddir.replace(top_builddir, top_srcdir)
elif builddir is None and srcdir is None:
    if savecwd.find(top_builddir):
        builddir = savecwd
        srcdir = builddir.replace(top_builddir, top_srcdir)
    elif savecws.find(top_srcdir):
        srcdir = savecwd
        builddir = srcdir.replace(top_srcdir, top_builddir)
    else:
        die('Cannot identify source dir nor build dir')
    
##################################################
# DETERMINE BUILDDIR
# add trailing slash to builddir
if not builddir.endswith('/'):
    builddir = builddir + '/'
# add trailing utdir to builddir
if not builddir.endswith(utdir):
    builddir += utdir

# check whether builddir is writeable, readable and executable
if os.access(builddir, os.F_OK):
    if not os.access(builddir, os.W_OK | os.X_OK | os.R_OK):
        die("Cannot access build dir " + builddir)
    create_builddir = False
else:
    create_builddir = True
if verbose: print("BUILDDIR = " + builddir)

##################################################
# DETERMINE SRCDIR
# add trailing slash to srcdir
if not srcdir.endswith('/'):
    srcdir = srcdir + '/'
# add trailing utdir to srcdir
if not srcdir.endswith(utdir):
    srcdir += utdir

# check whether srcdir is readable and executable
if not os.access(srcdir, os.R_OK | os.X_OK):
    die("Cannot access source dir " + srcdir)
if verbose:
    print("SRCDIR = " + srcdir)

##################################################
# DETERMINE WHICH TESTS TO RUN
os.chdir(srcdir)

class NoTest(Exception):
    pass

cpp_tests = []
py_tests = []
py_ptests = []

if len(tests):
    # split into different types of unittests
    for test in tests:
        if test.endswith('.py'):
            if test.startswith('test_'):
                py_tests.append(test)
                continue
            elif test.startswith('ptest_'):
                py_ptests.append(test)
                continue
            elif os.access('test_' + test, os.R_OK):
                py_tests.append('test_' + test)
                continue
            elif os.access('ptest_' + test, os.R_OK):
                py_ptests.append('ptest_' + test)
                continue
        elif test.endswith('.cpp'):
            if test.startswith('Test'):
                cpp_tests.append(test)
                continue
            elif os.access('Test' + test, os.R_OK):
                cpp_tests.append('Test' + test)
                continue
        elif test.startswith('Test'):
            if os.access(test + '.cpp', os.R_OK):
                cpp_tests.append(test + '.cpp')
                continue
        elif test.startswith('test_'):
            if os.access(test + '.py', os.R_OK):
                py_tests.append(test + '.py')
                continue
        elif test.startswith('ptest_'):
            if os.access(test + '.py', os.R_OK):
                py_ptests.append(test + '.py')
                continue
        else:
            if os.access('Test' + test + '.cpp', os.R_OK):
                cpp_tests.append('Test' + test + '.cpp')
                continue
            elif os.access('test_' + test + '.py', os.R_OK):
                py_tests.append('test_' + test + '.py')
                continue
            elif os.access('ptest_' + test + '.py', os.R_OK):
                py_ptests.append('ptest_' + test + '.py')
                continue
        die("Cannot identify test " + test)
else:
    # collect a list of unittests
    if clean or do_cpp:
        cpp_tests = glob.glob('Test*.cpp')
    if clean or do_python:
        py_tests = glob.glob('test_*.py')
    if clean or do_parallel:
        py_ptests = glob.glob('ptest_*.py')

# Check whether any unittests are there to handle
if not ((clean and (cpp_tests or py_tests or py_ptests)) or \
            (do_cpp and cpp_tests) or \
            (do_python and py_tests) or \
            (do_parallel and py_ptests)):
    print("No unittests to handle.")
    sys.exit(0)

if not HAVE_MPI:
    py_tests.extend(py_ptests)

if create_builddir:
    if verbose:
        print('Creating builddir.')
    # create builddir
    os.makedirs(builddir)

os.chdir(builddir)

if clean:
    print("Cleaning up.")
    if cpp_tests:
        LTCXXCLEAN = ''.join(
            [LTCALL, ' --mode=clean ', RM])
        if verbose:
            LTCXXCLEAN += ' -v'
        for test in cpp_tests:
            # strip ".cpp" from the end
            test = test[:-4]
            cmd = LTCXXCLEAN + ' ' + test + ' ' + test + '.lo'
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    print('ERROR: Cleaning test %s failed.' % test)
                    sys.exit(1)
    if py_tests or py_ptests:
        for test in py_tests + py_ptests:
            # strip ".py" from the end
            test = test[:-3]
            cmd = RM + ' ' + test + '.pyc'
            print(cmd)
            if not dryrun:
                if os.system(cmd):
                    print('ERROR: Cleaning test %s failed.' % test)
                    sys.exit(1)

if do_cpp:
    print("Will do the following C++ unittests:")
    print(cpp_tests)
if do_python:
    print("Will do the following Python unitests:")
    print(py_tests)
if HAVE_MPI and do_parallel:
    print("Will do the following parallel Python tests:")
    print(py_ptests)

if do_cpp and cpp_tests:
    print("\n**************************************************")
    print('**** COMPILING AND LINKING C++ UNITTESTS')
    ##################################################
    # COMBINE THE COMPILATION AND LINKER COMMANDS
    LTCXXCOMPILE = ''.join(
        [LTCALL,
         ' --mode=compile ', CXX,
         ' ', INCLUDES,
         ' ', CPPFLAGS,
         ' ', CXXFLAGS])
    LTCXXLINK = ''.join(
        [LTCALL,
         ' --mode=link ', CXXLD,
         ' ', CXXFLAGS,
         ' ', LDFLAGS,
         ' ', LIBS])
    LTRUN = LTCALL + ' --mode=execute'
    if verbose:
        LTRUN += ' -v'
        
        print("LTCXXCOMPILE = " + LTCXXCOMPILE)
        print("LTCXXLINK = " + LTCXXLINK)
        print("LTRUN = " + LTRUN)
        
    ##############################################
    # COMPILE AND LINK C++ UNITTESTS
    for test in cpp_tests:
        print("**************************************************")
        print("** " + test)

        # strip ".cpp" from the end
        test = test[:-4]

        print('** COMPILING ' + test)
        cmd = LTCXXCOMPILE + ' -c ' + srcdir + test + '.cpp'
        print(cmd)
        if not dryrun:
            if os.system(cmd):
                print('ERROR: Compiling test %s failed.' % test)
                sys.exit(1)
                
        print('\n** LINKING ' + test)
        cmd = LTCXXLINK + ' ' + test + '.lo -o ./' + test
        print(cmd)
        if not dryrun:
            if os.system(cmd):
                print('ERROR: Linking test %s failed.' % test)
                sys.exit(1)
                
    ##############################################
    # EXECUTE C++ UNITTESTS
    print("\n**************************************************")
    print('**** RUNNING C++ UNITTESTS')
    for test in cpp_tests:
        print("**************************************************")
        print("** " + test)
        # strip ".cpp" from the end
        cmd = LTRUN + ' ./' + test[:-4]
        print(cmd)
        if not dryrun:
            os.system(cmd)
            print('')

##############################################
# EXECUTE PYTHON UNITTESTS
if do_python and py_tests:
    print("\n**************************************************")
    print('**** RUNNING PYTHON UNITTESTS')
    for test in py_tests:
        print("**************************************************")
        print("** " + test)
        cmd = PYRUN + ' ' + srcdir + test
        if verbose: cmd += ' -v'
        print(cmd)
        if not dryrun:
            os.system(cmd)
            print('')

##############################################
# EXECUTE PARALLEL PYTHON UNITTESTS
if HAVE_MPI and do_parallel and py_ptests:
    if verbose:
        print('Executing ptests using %s MPI tasks' % num_tasks)
    print("\n**************************************************")
    print('**** RUNNING PARALLEL PYTHON UNITTESTS (%d CPUs)' % num_tasks)
    PARALLELPYTHON = ESPRESSO_MPIEXEC + ' -n ' + str(num_tasks) + ' ' + PYRUN
    for test in py_ptests:
        print("**************************************************")
        print("** " + test)
        cmd = PARALLELPYTHON + ' ' + srcdir + test
        if verbose: cmd += ' -v'
        print(cmd)
        if not dryrun:
            os.system(cmd)
            print('')

